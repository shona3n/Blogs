<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++11多线程并发 | Shona's Blog</title><meta name="keywords" content="thread"><meta name="author" content="Shona,shona.n@foxmail.com"><meta name="copyright" content="Shona"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="关于c++并发开发的知识">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11多线程并发">
<meta property="og:url" content="https://shona3n.github.io/2020/cpp/CPlusPlusConcurrency/index.html">
<meta property="og:site_name" content="Shona&#39;s Blog">
<meta property="og:description" content="关于c++并发开发的知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shona3n.github.io/img/per.jpg">
<meta property="article:published_time" content="2020-12-23T10:30:37.000Z">
<meta property="article:modified_time" content="2021-08-11T10:22:10.793Z">
<meta property="article:author" content="Shona">
<meta property="article:tag" content="thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shona3n.github.io/img/per.jpg"><link rel="shortcut icon" href="/assets/images/page.ico"><link rel="canonical" href="https://shona3n.github.io/2020/cpp/CPlusPlusConcurrency/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Shona","link":"链接: ","source":"来源: Shona's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-11 18:22:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/self/background.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/assets/images/pumpkin.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/per.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Shona's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++11多线程并发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-23T10:30:37.000Z" title="发表于 2020-12-23 18:30:37">2020-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-11T10:22:10.793Z" title="更新于 2021-08-11 18:22:10">2021-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cpp/">cpp</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>并发与并行的区别：多个进程运行在一个处理器上，这是并发；多个进程运行在不同的处理器上，这是并行。</p>
<p>线程：线程是操作系统能够进行CPU调度的最小单位，它被包含在进程之中，一个进程可包含单个或者多个线程。可以用多个线程去完成一个任务，也可以用多个进程去完成一个任务，它们的本质都相当于多个人去合伙完成一件事。</p>
<p>多线程并发：多线程是实现并发(双核的真正并行或者单核机器的任务切换都叫并发）的一种手段，多线程并发即多个线程同时执行,一般而言，多线程并发就是把一个任务拆分为多个子任务，然后交由不同线程处理不同子任务,使得这多个子任务同时执行。</p>
<p>C++多线程并发： C++98标准中并没有线程库的存在,而在C++11中终于提供了多线程的标准库,提供了管理线程、保护共享数据、线程间同步操作、原子操作等类，。（简单情况下）实现C++多线程并发程序的思路如下：将任务的不同功能交由多个函数分别实现，创建多个线程，每个线程执行一个函数，一个任务就这样同时分由不同线程执行了。</p>
<p>运行越多的线程，操作系统需要为每个线程分配独立的栈空间，需要越多的上下文切换，这会消耗很多操作系统资源，如果在线程上的任务完成得很快，那么实际执行任务的时间要比启动线程的时间小很多，所以在某些时候，增加一个额外的线程实际上会降低，而非提高应用程序的整体性能，此时收益就比不上成本。</p>
<h2 id="2-C-多线程并发基础知识"><a href="#2-C-多线程并发基础知识" class="headerlink" title="2. C++多线程并发基础知识"></a>2. C++多线程并发基础知识</h2><h3 id="2-1-创建线程"><a href="#2-1-创建线程" class="headerlink" title="2.1 创建线程"></a>2.1 创建线程</h3><p>首先要引入头文件#include<thread>，C++11中管理线程的函数和类在该头文件中声明，其中包括std::thread类。</thread></p>
<p>语句<code>std::thread th1(proc1);</code>创建了一个名为th1的线程，并且线程th1开始执行。</p>
<p>实例化std::thread类对象时，至少需要传递函数名作为参数。如果函数为有参函数,如<code>void proc2(int a,int b)</code>,那么实例化std::thread类对象时，则需要传递更多参数，参数顺序依次为函数名、该函数的第一个参数、该函数的第二个参数，···，如<code>std::thread th2(proc2,a,b);</code>。这里的传参，后续章节还会有详解与提升。</p>
<p>只要创建了线程对象（前提是，实例化std::thread对象时传递了“函数名/可调用对象”作为参数），线程就开始执行。</p>
<p>总之，使用C++线程库启动线程，可以归结为构造std::thread对象。</p>
<p>当线程启动后，一定要在和线程相关联的std::thread对象销毁前，对线程运用join()或者detach()方法。</p>
<p>join()与detach()都是std::thread类的成员函数，是两种线程阻塞方法，两者的区别是是否等待子线程执行结束。join()会阻塞主线程，直到子线程结束，detach()不阻塞主线程。<br>例如，主函数中有一条语句th1.join(),那么执行到这里，主函数阻塞，直到线程th1运行结束，主函数再继续运行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是子线程,传入参数为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程中显示子线程id为&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>()&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是主线程&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(proc, a)</span></span>; <span class="comment">// 第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程中显示子线程id为&quot;</span> &lt;&lt; th2.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    th2.<span class="built_in">join</span>()；<span class="comment">//此时主线程被阻塞直至子线程执行结束。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用join()会清理线程相关的存储部分，这代表了join()只能调用一次。使用joinable()来判断join()可否调用。同样，detach()也只能调用一次，一旦detach()后就无法join()了，有趣的是，detach()可否调用也是使用joinable()来判断。</p>
<p>如果使用detach()，就必须保证线程结束之前可访问数据的有效性，使用指针和引用需要格外谨慎。</p>
<h3 id="2-2-互斥量使用"><a href="#2-2-互斥量使用" class="headerlink" title="2.2 互斥量使用"></a>2.2 互斥量使用</h3><p>什么是互斥量？</p>
<p>这样比喻：单位上有一台打印机（共享数据a），你要用打印机（线程1要操作数据a），同事老王也要用打印机(线程2也要操作数据a)，但是打印机同一时间只能给一个人用，此时，规定不管是谁，在用打印机之前都要向领导申请许可证（lock），用完后再向领导归还许可证(unlock)，许可证总共只有一个,没有许可证的人就等着在用打印机的同事用完后才能申请许可证(阻塞，线程1lock互斥量后其他线程就无法lock,只能等线程1unlock后，其他线程才能lock)。那么，打印机就是共享数据，访问打印机的这段代码就是临界区，这个必须互斥使用的许可证就是互斥量。</p>
<p>互斥量是为了解决数据共享过程中可能存在的访问冲突的问题。这里的互斥量保证了使用打印机这一过程不被打断。</p>
<p>互斥量怎么使用？</p>
<p>首先需要#include<mutex>；（std::mutex和std::lock_guard都在<mutex>头文件中声明。）</mutex></mutex></p>
<p>然后需要实例化std::mutex对象；</p>
<p>最后需要在进入临界区之前对互斥量加锁，退出临界区时对互斥量解锁；</p>
<p>至此，互斥量走完了它的一生。</p>
<p>lock()与unlock():</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    proc1.<span class="built_in">join</span>();</span><br><span class="line">    proc2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在进入临界区之前对互斥量lock，退出临界区时对互斥量unlock；当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。</p>
<p>程序实例化mutex对象m,本线程调用成员函数m.lock()会发生下面 2 种情况： (1)如果该互斥量当前未上锁，则本线程将该互斥量锁住，直到调用unlock()之前，本线程一直拥有该锁。 (2)如果该互斥量当前被其他线程锁住，则本线程被阻塞,直至该互斥量被其他线程解锁，此时本线程将该互斥量锁住，直到调用unlock()之前，本线程一直拥有该锁。</p>
<p>不推荐实直接去调用成员函数lock()，因为如果忘记unlock()，将导致锁无法释放，使用lock_guard或者unique_lock则能避免忘记解锁带来的问题。</p>
<p><b>lock_guard:</b><br>std::lock_guard()是什么呢？它就像一个保姆，职责就是帮你管理互斥量，就好像小孩要玩玩具时候，保姆就帮忙把玩具找出来，孩子不玩了，保姆就把玩具收纳好。</p>
<p>其原理是：声明一个局部的std::lock_guard对象，在其构造函数中进行加锁，在其析构函数中进行解锁。最终的结果就是：创建即加锁，作用域结束自动解锁。从而使用std::lock_guard()就可以替代lock()与unlock()。</p>
<p>通过设定作用域，使得std::lock_guard在合适的地方被析构（在互斥量锁定到互斥量解锁之间的代码叫做临界区（需要互斥访问共享资源的那段代码称为临界区），临界区范围应该尽可能的小，即lock互斥量后应该尽早unlock），通过使用{}来调整作用域范围，可使得互斥量m在合适的地方被解锁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m)</span></span>;<span class="comment">//用此语句替换了m.lock()；lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//此时不需要写m.unlock(),g1出了作用域被释放，自动调用析构函数，于是m被解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="comment">//通过使用&#123;&#125;来调整作用域范围，可使得m在合适的地方被解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作用域外的内容5&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    proc1.<span class="built_in">join</span>();</span><br><span class="line">    proc2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::lock_gurad也可以传入两个参数，第一个参数为adopt_lock标识时，表示构造函数中不再进行互斥量锁定，因此此时需要提前手动锁定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;<span class="comment">//实例化m对象，不要理解为定义变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m.<span class="built_in">lock</span>();<span class="comment">//手动锁定</span></span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g1</span><span class="params">(m,adopt_lock)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">g2</span><span class="params">(m)</span></span>;<span class="comment">//自动锁定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    proc1.<span class="built_in">join</span>();</span><br><span class="line">    proc2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>unique_lock:</b><br>std::unique_lock类似于lock_guard,只是std::unique_lock用法更加丰富，同时支持std::lock_guard()的原有功能。 使用std::lock_guard后不能手动lock()与手动unlock();使用std::unique_lock后可以手动lock()与手动unlock(); std::unique_lock的第二个参数，除了可以是adopt_lock,还可以是try_to_lock与defer_lock;</p>
<p>try_to_lock: 尝试去锁定，得保证锁处于unlock的状态,然后尝试现在能不能获得锁；尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里，并继续往下执行；</p>
<p>defer_lock: 始化了一个没有加锁的mutex;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">g1</span><span class="params">(m, defer_lock)</span></span>;<span class="comment">//始化了一个没有加锁的mutex</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不拉不拉不拉&quot;</span> &lt;&lt; endl;</span><br><span class="line">    g1.<span class="built_in">lock</span>();<span class="comment">//手动加锁，注意，不是m.lock();注意，不是m.lock(),m已经被g1接管了;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;proc1函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    g1.<span class="built_in">unlock</span>();<span class="comment">//临时解锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不拉不拉不拉&quot;</span>  &lt;&lt; endl;</span><br><span class="line">    g1.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不拉不拉不拉&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">g2</span><span class="params">(m,try_to_lock)</span></span>;<span class="comment">//尝试加锁一次，但如果没有锁定成功，会立即返回，不会阻塞在那里，且不会再次尝试锁操作。</span></span><br><span class="line">    <span class="keyword">if</span>(g2.owns_lock)&#123;<span class="comment">//锁成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;proc2函数正在改写a&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;原始a为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;现在a为&quot;</span> &lt;&lt; a + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//锁失败则执行这段语句</span></span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc1</span><span class="params">(proc1, a)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">proc2</span><span class="params">(proc2, a)</span></span>;</span><br><span class="line">    proc1.<span class="built_in">join</span>();</span><br><span class="line">    proc2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用try_to_lock要小心，因为try_to_lock尝试锁失败后不会阻塞线程，而是继续往下执行程序，因此，需要使用if-else语句来判断是否锁成功,只有锁成功后才能去执行互斥代码段。而且需要注意的是，因为try_to_lock尝试锁失败后代码继续往下执行了，因此该语句不会再次去尝试锁。</p>
<p>std::unique_lock所有权的转移</p>
<p>注意，这里的转移指的是std::unique_lock对象间的转移；std::mutex对象的所有权不需要手动转移给std::unique_lock , std::unique_lock对象实例化后会直接接管std::mutex。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutex m;</span><br><span class="line">&#123;  </span><br><span class="line">    unique_lock&lt;mutex&gt; g2(m,defer_lock);</span><br><span class="line">    unique_lock&lt;mutex&gt; g3(move(g2));<span class="comment">//所有权转移，此时由g3来管理互斥量m</span></span><br><span class="line">    g3<span class="selector-class">.lock</span>();</span><br><span class="line">    g3<span class="selector-class">.unlock</span>();</span><br><span class="line">    g3<span class="selector-class">.lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>condition_variable:</b><br>需要#include<condition_variable>，该头文件中包含了条件变量相关的类，其中包括std::condition_variable类</condition_variable></p>
<p>如何使用？std::condition_variable类搭配std::mutex类来使用，std::condition_variable对象(std::condition_variable cond;)的作用不是用来管理互斥量的，它的作用是用来同步线程，它的用法相当于编程中常见的flag标志（A、B两个人约定flag=true为行动号角，默认flag为false,A不断的检查flag的值,只要B将flag修改为true，A就开始行动）。</p>
<p>类比到std::condition_variable，A、B两个人约定notify_one为行动号角，A就等着（调用wait(),阻塞）,只要B一调用notify_one，A就开始行动（不再阻塞）。</p>
<p>std::condition_variable的具体使用代码实例可以参见文章中“生产者与消费者问题”章节。</p>
<p><b>wait(locker) :</b></p>
<p>wait函数需要传入一个std::mutex（一般会传入std::unique_lock对象）,即上述的locker。wait函数会自动调用 locker.unlock() 释放锁（因为需要释放锁，所以要传入mutex）并阻塞当前线程，本线程释放锁使得其他的线程得以继续竞争锁。一旦当前线程获得notify(通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数此时再自动调用 locker.lock()上锁。</p>
<p>cond.notify_one(): 随机唤醒一个等待的线程</p>
<p>cond.notify_all(): 唤醒所有等待的线程</p>
<h3 id="2-3-异步线程"><a href="#2-3-异步线程" class="headerlink" title="2.3 异步线程"></a>2.3 异步线程</h3><p>需要#include<future></future></p>
<p>async与future：<br>std::async是一个函数模板，用来启动一个异步任务，它返回一个std::future类模板对象，future对象起到了占位的作用（记住这点就可以了），占位是什么意思？就是说该变量现在无值，但将来会有值（好比你挤公交瞧见空了个座位，刚准备坐下去就被旁边的小伙给拦住了：“这个座位有人了”，你反驳道：”这不是空着吗？“，小伙：”等会人就来了“）,刚实例化的future是没有储存值的，但在调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future，即通过FutureObject.get()获取函数返回值。</p>
<p>相当于你去办政府办业务（主线程），把资料交给了前台，前台安排了人员去给你办理（std::async创建子线程），前台给了你一个单据（std::future对象），说你的业务正在给你办（子线程正在运行），等段时间你再过来凭这个单据取结果。过了段时间，你去前台取结果（调用get()），但是结果还没出来（子线程还没return），你就在前台等着（阻塞），直到你拿到结果（子线程return），你才离开（不再阻塞）。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">t1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> a, <span class="keyword">const</span> <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">double</span> c = a + b;</span><br><span class="line"> <span class="built_in">Sleep</span>(<span class="number">3000</span>);<span class="comment">//假设t1函数是个复杂的计算过程，需要消耗3秒</span></span><br><span class="line"> <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">double</span> a = <span class="number">2.3</span>;</span><br><span class="line"> <span class="keyword">double</span> b = <span class="number">6.7</span>;</span><br><span class="line"> future&lt;<span class="keyword">double</span>&gt; fu = <span class="built_in">async</span>(t1, a, b);<span class="comment">//创建异步线程线程，并将线程的执行结果用fu占位；</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;正在进行计算&quot;</span> &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;计算结果马上就准备好，请您耐心等待&quot;</span> &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">//阻塞主线程，直至异步线程return</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;计算结果：&quot; &lt;&lt; fu.get() &lt;&lt; endl;//取消该语句注释后运行会报错，因为future对象的get()方法只能调用一次。</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b>shared_future</b></p>
<p>std::future与std::shard_future的用途都是为了占位，但是两者有些许差别。std::future的get()成员函数是转移数据所有权;std::shared_future的get()成员函数是复制数据。 因此： future对象的get()只能调用一次；无法实现多个线程等待同一个异步线程，一旦其中一个线程获取了异步线程的返回值，其他线程就无法再次获取。 std::shared_future对象的get()可以调用多次；可以实现多个线程等待同一个异步线程，每个线程都可以获取异步线程的返回值。</p>
<p>2.4 原子类型atomic&lt;&gt;<br>原子操作指“不可分割的操作”，也就是说这种操作状态要么是完成的，要么是没完成的，不存在“操作完成了一半”这种状况。互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量(操作变量时加锁防止他人干扰)。 std::atomic&lt;&gt;是一个模板类，使用该模板类实例化的对象，提供了一些保证原子性的成员函数来实现共享数据的常用操作。</p>
<p>可以这样理解： 在以前，定义了一个共享的变量(int i=0)，多个线程会用到这个变量，那么每次操作这个变量时，都需要lock加锁，操作完毕unlock解锁，以保证线程之间不会冲突；但是这样每次加锁解锁、加锁解锁就显得很麻烦，那怎么办呢？ 现在，实例化了一个类对象(std::atomic<int> I=0)来代替以前的那个变量（这里的对象I你就把它看作一个变量，看作对象反而难以理解了），每次操作这个对象时，就不用lock与unlock，这个对象自身就具有原子性（相当于加锁解锁操作不用你写代码实现，能自动加锁解锁了），以保证线程之间不会冲突。</int></p>
<p>提到std::atomic&lt;&gt;，你脑海里就想到一点就可以了：std::atomic&lt;&gt;用来定义一个自动加锁解锁的共享变量（“定义”“变量”用词在这里是不准确的，但是更加贴切它的实际功能），供多个线程访问而不发生冲突。</p>
<p>//原子类型的简单使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>std::atomic&lt;&gt;对象提供了常见的原子操作（通过调用成员函数实现对数据的原子操作）： store是原子写操作，load是原子读操作。exchange是于两个数值进行交换的原子操作。 即使使用了std::atomic&lt;&gt;，也要注意执行的操作是否支持原子性，也就是说，你不要觉得用的是具有原子性的变量（准确说是对象）就可以为所欲为了，你对它进行的运算不支持原子性的话，也不能实现其原子效果。一般针对++，–，+=，-=，&amp;=，|=，^=是支持的，这些原子操作是通过在std::atomic&lt;&gt;对象内部进行运算符重载实现的。</p>
<h2 id="3-代码实例"><a href="#3-代码实例" class="headerlink" title="3 代码实例"></a>3 代码实例</h2><p>前一章内容为了简单的说明一些函数的用法，所列举的例子有些牵强，因此在本章列举了一些多线程常见的实例</p>
<h3 id="3-1-生产者消费者问题"><a href="#3-1-生产者消费者问题" class="headerlink" title="3.1 生产者消费者问题"></a>3.1 生产者消费者问题</h3><p>生产者-消费者模型是经典的多线程并发协作模型。生产者用于生产数据，生产一个就往共享数据区存一个，如果共享数据区已满的话，生产者就暂停生产；消费者用于消费数据，一个一个的从共享数据区取，如果共享数据区为空的话，消费者就暂停取数据，且生产者与消费者不能直接交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者消费者问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">mutex mu;</span><br><span class="line">condition_variable cond;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//缓冲区的产品个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">int</span> data1;</span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//通过外层循环，能保证生产不停止</span></span><br><span class="line">  <span class="keyword">if</span>(c &lt; <span class="number">3</span>) &#123;<span class="comment">//限流</span></span><br><span class="line">   &#123;</span><br><span class="line">    data1 = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;<span class="comment">//锁</span></span><br><span class="line">    q.<span class="built_in">push_front</span>(data1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;存了&quot;</span> &lt;&lt; data1 &lt;&lt; endl;</span><br><span class="line">    cond.<span class="built_in">notify_one</span>();  <span class="comment">// 通知取</span></span><br><span class="line">    ++c;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">Sleep</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> data2;<span class="comment">//data用来覆盖存放取的数据</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mu)</span></span>;</span><br><span class="line">   <span class="keyword">while</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">    cond.<span class="built_in">wait</span>(locker); <span class="comment">//wait()阻塞前先会解锁,解锁后生产者才能获得锁来放产品到缓冲区；生产者notify后，将不再阻塞，且自动又获得了锁。</span></span><br><span class="line">   data2 = q.<span class="built_in">back</span>();<span class="comment">//取的第一步</span></span><br><span class="line">   q.<span class="built_in">pop_back</span>();<span class="comment">//取的第二步</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;取了&quot;</span> &lt;&lt; data2&lt;&lt;endl;</span><br><span class="line">   --c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Sleep</span>(<span class="number">1500</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line"> <span class="function">thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line"> t1.<span class="built_in">join</span>();</span><br><span class="line"> t2.<span class="built_in">join</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-C-多线程并发高级知识"><a href="#4-C-多线程并发高级知识" class="headerlink" title="4 C++多线程并发高级知识"></a>4 C++多线程并发高级知识</h2><h3 id="4-1-线程池"><a href="#4-1-线程池" class="headerlink" title="4.1 线程池"></a>4.1 线程池</h3><h4 id="4-1-1-线程池基础知识"><a href="#4-1-1-线程池基础知识" class="headerlink" title="4.1.1 线程池基础知识"></a>4.1.1 线程池基础知识</h4><p>不采用线程池时：</p>
<p>创建线程 -&gt; 由该线程执行任务 -&gt; 任务执行完毕后销毁线程。即使需要使用到大量线程，每个线程都要按照这个流程来创建、执行与销毁。</p>
<p>虽然创建与销毁线程消耗的时间 远小于 线程执行的时间，但是对于需要频繁创建大量线程的任务，创建与销毁线程 所占用的时间与CPU资源也会有很大占比。</p>
<p>为了减少创建与销毁线程所带来的时间消耗与资源消耗，因此采用线程池的策略：</p>
<p>程序启动后，预先创建一定数量的线程放入空闲队列中，这些线程都是处于阻塞状态，基本不消耗CPU，只占用较小的内存空间。</p>
<p>接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。</p>
<p>任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。</p>
<p>线程池所解决的问题：</p>
<p>(1) 需要频繁创建与销毁大量线程的情况下，由于线程预先就创建好了，接到任务就能马上从线程池中调用线程来处理任务，减少了创建与销毁线程带来的时间开销和CPU资源占用。</p>
<p>(2) 需要并发的任务很多时候，无法为每个任务指定一个线程（线程不够分），使用线程池可以将提交的任务挂在任务队列上，等到池中有空闲线程时就可以为该任务指定线程。</p>
<h4 id="4-1-2-线程池的实现"><a href="#4-1-2-线程池的实现" class="headerlink" title="4.1.2 线程池的实现"></a>4.1.2 线程池的实现</h4><p>可以通过阅读 《C++ Concurrency in Action, Second Edition》 9.1章节来学习。线程池确实是难点部分，所以先拖着不更，等把别的章节完善了，再来更新这部分。， 本文的线程池实现的内容将会在《C++11 STL基础入门教程》完善后再来更新。</p>
<h2 id="5-延伸拓展"><a href="#5-延伸拓展" class="headerlink" title="5 延伸拓展"></a>5 延伸拓展</h2><h3 id="5-1-线程与进程-并发与并行"><a href="#5-1-线程与进程-并发与并行" class="headerlink" title="5.1 线程与进程/并发与并行"></a>5.1 线程与进程/并发与并行</h3><p>这里借用了C++标准委员会成员Anthony Willianms在书籍《C++ Concurrency in Action, Second Edition》中的表述（强推这本书，写的真的很好）：</p>
<p>并发的两种方式： 双核及其的真正并行、单核机器的任务切换</p>
<p>并发的两种基本途径：多进程并发、多线程并发</p>
<p>多进程并发： 优点是更容易编写安全的并发代码（操作系统为进程通信提供了一定的保护措施）、可分布式（可以通过远程连接的方式在不同的计算机上独立运行进程）；缺点是进程开销大、启动慢，进程之前的通信复杂耗时。</p>
<p>多线程并发： 优点是共享内存的灵活性（进程中的所有线程共享内存地址空间。虽然进程之前也共享内存，但这种共享通常是难以管理的，因为同一数据的内存地址在不同的进程中是不同的），缺点是编写代码时工作量大（需要保证多个线程访问到的共享数据是一致的）</p>
<p>结论是，多个进程（每个进程只包含单一线程）比多个线程（单一进程包含的多个线程）的开销大，若不考虑共享内存所带来的问题，多线程将会成为主流语言更加青睐的并发途径。</p>
<p>并发与并行： 对于多线程来说，两者概念大部分重叠，意思近乎相同，只是侧重点不同，关注于使用当前可用硬件来提高批量数据处理的速度时，我们讨论程序的并行性，关注于任务分离或任务响应时，就会讨论到程序的并发性。（我的理解：并发概念中涵盖了并行）</p>
<h3 id="5-2-创建线程时的传参问题分析"><a href="#5-2-创建线程时的传参问题分析" class="headerlink" title="5.2 创建线程时的传参问题分析"></a>5.2 创建线程时的传参问题分析</h3><p>如<code>std::thread th1(proc1)</code>,创建线程时需要传递函数名作为参数，提供的函数对象会复制到新的线程的内存空间中执行与调用。</p>
<p>如果用于创建线程的函数为含参函数，那么在创建线程时，要一并将函数的参数传入。常见的，传入的参数的形式有基本数据类型(int，char,string等)、引用、指针、对象这些，下面总结了传递不同形式的参数时std::thread类的处理机制，以及编写程序时候的注意事项。本章节只给出了部分示例代码，没有必要为了证明处理机制而举例大量简单代码而使得文章冗长，但是推荐新手自行编写程序研究。</p>
<p>总体来说，std::thread的构造函数会拷贝传入的参数:</p>
<ol>
<li><p>当传入参数为基本数据类型(int，char,string等)时，会拷贝一份给创建的线程；</p>
</li>
<li><p>当传入参数为指针时，会浅拷贝一份给创建的线程，也就是说，只会拷贝对象的指针，不会拷贝指针指向的对象本身。</p>
</li>
<li><p>当传入的参数为引用时，实参必须用ref()函数处理后传递给形参，否则编译不通过，此时不存在“拷贝”行为。引用只是变量的别名，在线程中传递对象的引用，那么该对象始终只有一份，只是存在多个别名罢了（注意把引用与指针区别开：指针是一块内存指向另一块内存，指针侧重“指向”二字；引用是只有一块内存，存在多个别名。理解引用时不要想着别名“指向”内存，这是错误的理解，这样的理解会导致分不清指针和引用，别名与其本体侧重于“一体”二字，引用就是本体，本体就是引用，根本没有“指向”关系。）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;&amp;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">	cout&lt;&lt; a &lt;&lt;<span class="string">&quot;,,&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(proc,ref(a))</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>当传入的参数为类对象时，会拷贝一份给创建的线程。此时会调用类对象的拷贝构造函数。</p>
</li>
</ol>
<h3 id="5-3-detach"><a href="#5-3-detach" class="headerlink" title="5.3 detach()"></a>5.3 detach()</h3><p>使用detach()时，可能存在主线程比子线程先结束的情况，主线程结束后会释放掉自身的内存空间；在创建线程时，如果std::thread类传入的参数含有引用或指针，则子线程中的数据依赖于主线程中的内存，主线程结束后会释放掉自身的内存空间，则子线程会出现错误。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:shona.n@foxmail.com">Shona</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shona3n.github.io/2020/cpp/CPlusPlusConcurrency/">https://shona3n.github.io/2020/cpp/CPlusPlusConcurrency/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shona3n.github.io" target="_blank">Shona's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/thread/">thread</a></div><div class="post_share"><div class="social-share" data-image="/img/per.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/assets/images/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/assets/images/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/coding/%E5%8F%AF%E8%A2%AB5%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80/"><img class="prev-cover" data-lazy-src="/img/per.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">可被5整除的二进制前缀</div></div></a></div><div class="next-post pull-right"><a href="/2020/mine/birthdaybook/"><img class="next-cover" data-lazy-src="/img/per.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">生命的价值</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/assets/images/pumpkin.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Shona</div><div class="author-info__description">我在过去，我在现在，我在将来</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/shona3n"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shona3n" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:shona.n@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">2. C++多线程并发基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BA%92%E6%96%A5%E9%87%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 互斥量使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 异步线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">3 代码实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 生产者消费者问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86"><span class="toc-number">4.</span> <span class="toc-text">4 C++多线程并发高级知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 线程池基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 线程池的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BB%B6%E4%BC%B8%E6%8B%93%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">5 延伸拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 线程与进程&#x2F;并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%97%B6%E7%9A%84%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 创建线程时的传参问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-detach"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 detach()</span></a></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Shona</div><div class="footer_custom_text">江河回望</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/self/background.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>